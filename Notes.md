# Processes 

1. Memory: A process is given or allocated only a certain portion of ram. Other processes will be given its own portion of ram. Processes in general do not access other process allocated ram. Processes are essentially isolated from one another in terms of allocating memory from ram. These describe civilian processes.

2. Operating System Processes: Operating system is what polices, using elevated permissions, civilian processes by making sure they are not accessing other process's allocated ram. However, in order to do this, operating system itself must and does access the ram of other processes.

3. Process States: processes have states which describes the action the process is currently performing. Process state can be different depending on Os but some basic ones include 'ready', 'waiting', 'running' and 'terminated.' 

4. Child processes: Processes will need to have child processes as it is often the child processes that perform the actual action while the parent processes may provide the ui. e.g the terminal as the parent process and the commands like 'ls' as the child process. 

5. System Call: Creating another process from an existing process can only be done by a privileged process. Cilivian processes cannot create new processes on their own. The kernel/operating system intervenes when a civilian process wants to create a new process. A system call is a api of different functions and procedures, that is exposed to civilian processes that allows cilivian processes to ask the operating system to create the new processes for the cilivian processes by allocating the memory needed etc. Civlian process makes the system call and allows civilian processes have access to priveleged operations and operating system managing them. Examples of system calls include fork(), exec(), etc

6. fork(): fork is used by the parent process to created a child process. It fetches the processes identification number (pid) and then fork is actually called. If successful, a new process is spawned. Parents gets pid of the child that has spawned. e.g int rc = fork(); 'rc' is the pid of child if rc <0, this means fork has failed or it will equal 0 to indicated success. Child cannot access Parent pid but parent can access pid of child. Child just copies the program counter of the parent and keeps moving without re running all the code the parent has already ran before the current program counter. If rc is 0, then you know you are ruynning the child processes.

7. wait(): Wait system call have multiple forms. There are multiple wait functions including 'wait' waitpid' and 'waitid'. Wait is used for to wait for state changes in the child. The parent will run only after the child processes finished first. You cannot make the child wait because the child does not know the parent pid. It is aspect of scheduling processes which determines when processes begins and both are priveleged process so the civilian process will not be able to undermine the scheduler.
int wc = wait(pid, NULL, 0)

8. exec(): Another family of functions rather than one paricular funciton. Fork only gives half of what we need because it only runs based on the parent processes. Howver, we often need child process to do something else or executing something else. Exec transforms the processes it was called in into its own program. After exec, the child is no longer a clone of its parent but executes its own program. The name of the new program is passed into the exec function. The ID itself remains the same. You can also pass in arguments which specifies the actions performed by new process. There are many variations of exec and the differences comes from they are called and how the arguments are called such as passing in arrays or strings.

9. pipe(): Processes by default are isolated with own blocks of ram . However, pipe allows for a uni-directional connection betweeen two processes that would otherwise be isolated from each other. Bi- directional communication would require two uni directional pipes. You need variables to hold the data coming in through the pipes such as an array or string. Bi directional will require at least two such as writing data to another process and then reading data coming from that process. The write() function writes to the pipe and read() read off the pipe to get that data. read( p[0], inbuf, MSGSIZE); inbuf btw is what holds the incoming data.  